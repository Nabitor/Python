###Python正则表达式
- 所有这些内容都在regular_expression.py中进行了实践
####正则表达式语法
- '.':（点）在默认模式下，它匹配除换行符之外的任何字符。 如果指定了DOTALL标志，则它匹配任何字符，包括换行符。
- '^':匹配字符串的开头，在MULTILINE模式下，每个换行符后立即匹配。
- '$':匹配字符串的结尾或刚好在字符串结尾处的换行符之前，并且在MULTILINE模式下，在换行符之前匹配。 foo匹配'foo'和'foobar'，而正则表达式foo $仅匹配'foo'。 更有趣的是，在'foo1\nfoo2\n'中搜索foo。$通常匹配'foo2'，而在MULTILINE模式中匹配'foo1' 在“foo\n”中搜索单个$将会找到两个（空）匹配：一个在换行之前，一个在字符串的结尾。
-  '*':匹配前面的re0次或者多次，并尽可能多次重复。ab\*将匹配'a'，'ab'或'a'，后跟任意数目的'b'。
-  '+':匹配前面RE的1次或多次重复。 ab+将匹配'a'，后跟任何非零数字'b'; 它将不匹配只是'a'。
-  '?':匹配前面RE的0个或1个重复。 ab？将匹配'a'或'ab'。
-  *?, +?, ??:\*, +, ?限定词都是贪婪的；它们匹配尽可能多的文本，但有时这种行为是不希望出现的。如果RE<.\*>与<a><b><c>匹配，它将匹配整个字符串，而不仅仅是<a>，添加?在限定词使其以非贪婪或最小的方式执行匹配之后，将匹配尽可能少的字符。如使用<?,>则只匹配<a>。
-  {m}:指定应匹配前一个RE的正好m个副本; 而较少的匹配导致整个RE不匹配。 例如，{6}将匹配六个“a”字符，而不是五个。
-  {m,n}:从前面的RE匹配m到n次重复，并且会尝试匹配尽可能多的重复。 例如，{3,5}将匹配3到5个'a'字符。省略m指定零的下限，省略n指定无限上限。 例如，{4，} b将匹配aaaab或一千个'a'字符，后跟一个b，但不匹配aaab。 逗号尽量不要省略，或者修饰符不要与先前描述的形式混淆。
-  {m,n}?:从前面的RE匹配m到n次重复，并且尝试匹配尽可能少的重复。 这是以前的限定词的非贪婪版本。 例如，对于6个字符的字符串'aaaaaa'，{3,5}将匹配5'a'个字符，而{3,5}？ 将只匹配3个字符。
-  '\':可以转义特殊字符（允许匹配诸如'*'，'？'等字符），或发出特殊序列的信号; 下面讨论特殊序列。如果你不使用原始字符串来表达模式，记住Python也使用反斜杠作为字符串文字中的转义序列; 如果Python解析器无法识别转义序列，则反斜杠和后续字符将包含在生成的字符串中。 然而，如果Python将识别结果序列，反斜杠应该重复两次。 这非常复杂而且难以理解，所以强烈建议您使用原始字符串，除了最简单的表达式。
-  []:用于匹配一组字符。用于表示一组字符。在一组[]中：字符可以单独列出，例如。 [amk]将匹配'a'，'m'或'k'。字符的范围可以通过给出两个字符并用“ - ”分隔，例如[az]将匹配任何小写ASCII字母，[0-5] [0-9]将匹配所有的两位数字00到59，[0-9A-Fa-f]将匹配任何十六进制数字。如果 - 被转义（例如[a \ -z]），或者如果它被放置为第一个或最后一个字符（例如[a-]），它将匹配一个文字' - '。
特殊字符在集合中失去其特殊含义。例如，[（+ *）]将匹配任何文字字符'（'，'+'，'*'或'）'。字符类，例如\ w或\ S（下面定义）也可以在集合中被接受，尽管它们匹配的字符取决于LOCALE或UNICODE模式是否有效。不在一个范围内的字符可以通过补集集合来匹配。如果集合的第一个字符是“^”，则不匹配集合中的所有字符。例如，[^ 5]将匹配除“5”以外的任何字符，并且[^^]将匹配除“^”之外的任何字符。 ^没有特殊的意义，如果它不是集合中的第一个字符。要在集合中匹配文字']'，在其前面加上反斜杠，或将其放在集合的开头。例如，[（）[\] {}]和[]（）[{}]都将匹配一个括号。
- '|':A | B，其中A和B可以是任意的RE，创建将匹配A或B的正则表达式。任意数量的RE可以由'|' 分割。这同样也可以在组内使用（见下文）。 当扫描目标字符串时，由“|”分隔的RE， 从左到右尝试。 当一个模式完全匹配时，接受该分支。 这意味着一旦A匹配，B将不会被进一步测试，即使它将产生更长的整体匹配。 换句话说，'|' 操作员永远不会贪婪。 要匹配文字'|'，请使用\ |，或将其包含在字符类中，如[|]。
- (...):匹配括号内的任何正则表达式，并指示组的开始和结束; 可以在执行匹配之后检索组的内容，并且可以稍后在字符串中与下面描述的\ number特殊序列匹配。 要匹配文本'（'或'）'，使用\（或\），或将它们包含在字符类中：[（] [）]。
- (?...):这是一个扩展符号((后面跟着?)。'?'后面的第一个字符决定了什么含义和进一步的语法构造。这种扩展通常不创建一个新的组; （?P<name>...）是此规则的唯一例外。以下是当前支持的扩展。
- (?iLmsux):（来自集合'i'，'L'，'m'，'s'，'u'，'x'的一个或多个字母。字母设置相应的标志：re.I（忽略大小写），re.L（依赖于locale），re.M（多行），re.S（点匹配所有），re.U（Unicode依赖） re.X（verbose），用于整个正则表达式。（这些标志在模块内容中描述。）如果希望将标志作为正则表达式的一部分，而不是将标志参数传递给re.compile（）函数，这将非常有用。注意，（？x）标志改变表达式的解析方式。它应该首先在表达式字符串中使用，或者在一个或多个空格字符之后使用。如果在标志之前有非空格字符，结果是未定义的。
- (?:...):非捕获版本的常规括号。匹配括号中的任何正则表达式，但在执行匹配或稍后在模式中引用时，无法检索由组匹配的子字符串。
- (?P<name>...):类似于常规括号，但是组匹配的子字符串可通过符号组名称name访问。 组名称必须是有效的Python标识符，每个组名称只能在正则表达式中定义一次。 符号组也是编号组，就像组没有命名一样。
- (?P=name):对指定组的反向引用; 它匹配任何由名为name的早期组匹配的文本。
- (?#...):括号的内容被简单地忽略。
- (?=...):匹配if...匹配next，但不消耗任何字符串。这被称为先行断言。 例如，Isaac（？= Asimov）将匹配'Isaac'，如果它后面是'Asimov'。
- (?!...):如果...不匹配下一个则匹配完成。这是一个负前瞻断言。 例如，Isaac（？！Asimov）将匹配'Isaac'，只有当它不跟随'Asimov'。
- (?<=...):如果字符串中的当前位置前面有一个匹配则匹配成功，并于当前位置结束。 这被称为肯定的后瞻断言。(?<= abc)def将在abcdef中找到一个匹配，因为lookbehind将会备份3个字符，并检查包含的模式是否匹配。包含的模式只能匹配一些固定长度的字符串，这意味着允许abc或a | b，但不允许a *和a {3,4}。 不支持组引用，即使它们匹配一些固定长度的字符串。请注意，以肯定的后瞻断言开始的模式在被搜索的字符串的开头将不匹配。
- (?<...):如果字符串中的当前位置前面没有匹配的....则匹配成功，这被称为负后备断言。 与positive lookbehind断言类似，包含的模式只能匹配某个固定长度的字符串，并且不应包含组引用。 以负的后端断言开始的模式可能在被搜索的字符串的开头匹配。
- (?(id/name)yes-pattern|no-pattern):如果具有给定id或名称的组存在，则尝试与yes-pattern匹配，如果不存在，则尝试与no-pattern匹配。no-pattern是可选的，可以省略。 例如，(<)?(\w+@\w+(?:\.\w+)+)(?(1)>)是一个糟糕的电子邮件匹配模式，将匹配'<user@host.com> 以及“user@host.com”，但不与“<user@host.com”匹配。

####Python正则表达式技巧
- 使用sub方法替换字符串
- 管理复杂的正则表达式可以使用多行注释